<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Maze Navigation Experiment</title>

  <!-- jsPsych core + CSS -->
  <link href="https://unpkg.com/jspsych@8.2.1/css/jspsych.css" rel="stylesheet" type="text/css" />
  <script src="https://unpkg.com/jspsych@8.2.1"></script>

  <!-- Plugins -->
  <script src="https://unpkg.com/@jspsych/plugin-preload@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-instructions@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-image-keyboard-response@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-fullscreen@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-call-function@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-text@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-button-response@2.1.0"></script>

  <!-- Optional data handler the original file used -->
  <script src="modular-data-handler.js"></script>

  <style>
  :root{
    /* sizing */
    --stimulus-size: 350px;          /* inner drawable square */
    --frame-gap: 50px;               /* padding between image and frame */
    --frame-border: 12px;            /* frame thickness */
    --frame-color: #000;

    /* fixation */
    --fixation-color: #808080;       /* grey */
    --fixation-size: 28px;
    --fixation-thickness: 3px;
  }

  /* ===== Outer frame (black square around the maze) ===== */
  .stimulus-frame{
    position: relative;
    width:  calc(var(--stimulus-size) + 2 * var(--frame-gap));
    height: calc(var(--stimulus-size) + 2 * var(--frame-gap));
    padding: var(--frame-gap);
    border: var(--frame-border) solid var(--frame-color);
    margin: 2vh auto;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: #fff;
    box-sizing: content-box;
  }

  /* ===== Fixed inner square the maze must fit in ===== */
  .stimulus-frame > .frame-content{
    position: relative;
    width: var(--stimulus-size) !important;
    height: var(--stimulus-size) !important;
    flex: 0 0 auto !important;          /* never stretch */
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0;
    aspect-ratio: 1 / 1;                 /* belt & suspenders */
  }

  /* ===== Overlay that covers the inner square exactly ===== */
  .stimulus-overlay{
    position: relative;
    width: 100%;
    height: 100%;
    display: block;
    line-height: 0;
  }

  /* ===== The maze image itself =====
     Fit inside the square (scale up/down, keep aspect) */
  #jspsych-image-keyboard-response-stimulus{
    width: 100% !important;
    height: 100% !important;
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    display: block;
  }

  /* Hide the browser "broken image" icon during ISI / empty src */
  .stimulus-overlay img[src=""],
  .stimulus-overlay img:not([src]),
  .stimulus-overlay img.broken{
    opacity: 0; /* keep layout so fixation stays centered */
  }

  /* ===== Fixation cross (on top of the maze) ===== */
  .fixation{
    position: absolute;
    left: 50%;
    top: 50%;
    width: var(--fixation-size);
    height: var(--fixation-size);
    transform: translate(-50%, -50%);
    pointer-events: none;
    z-index: 10;
  }
  .fixation::before,
  .fixation::after{
    content: "";
    position: absolute;
    background: var(--fixation-color);
  }
  /* vertical bar */
  .fixation::before{
    left: 50%;
    top: 0;
    width: var(--fixation-thickness);
    height: 100%;
    transform: translateX(-50%);
  }
  /* horizontal bar */
  .fixation::after{
    left: 0;
    top: 50%;
    width: 100%;
    height: var(--fixation-thickness);
    transform: translateY(-50%);
  }

  /* ===== Practice caption goes BELOW the square ===== */
  .frame-caption{
    margin-top: 8px;
    text-align: center;
    line-height: 1.2;
  }

  /* ===== Optional feedback colors on the frame border ===== */
  .frame-correct{ border-color: #008000 !important; }
  .frame-wrong{   border-color: #FF0000 !important; }
</style>

</head>

<body>
<div id="jspsych-target"></div>

<script>

    // --- Experiment Parameters ---
    const base_image_path = "maze_images/";

    const TRIAL_CONDITIONS = {
        "far": "maze_initial_small.png",
        "closer": "maze_closer_small.png",
        "closest": "maze_closest_small.png",
        "target": "maze_goal_small.png"
    }

    const target_image = TRIAL_CONDITIONS["target"]; // The target image participants should respond to
    const nTrialsPerImage = 30; // How many times each image appears
    const targetRepeats = 10; // How many times target appears per cycle

    const iti = 1200; // Inter-trial interval (msec)
    const shapePresentationDuration = 600; // Image display duration (msec)

    const feedbackColor = '#008000'; // Green for correct responses
    const wrongColor = '#FF0000'; // Red for incorrect responses
    const feedbackDuration = 300; // How long the border color stays changed after a response

    const jsPsych = initJsPsych({
        override_safe_mode: true,
        show_progress_bar: true,
        message_progress_bar: 'Progress',
        auto_update_progress_bar: false,

        // Set callbacks
        on_data_update: function(data){
            console.log('on_data_update called!', data.trial_type);

            if (dataHandler.isLocal){
                // Local mode - download data
                console.log('Trial data collected (local):', {
                trial_type: data.trial_type,
                trial_index: data.trial_index,
                rt: data.rt,
                response: data.response
            });
            } else {
                // Server mode
                dataHandler.submitData(data)
                    .then(result => console.log('Trial data submitted:', result.method))
                    .catch(error => console.error('Trial submission failed:', error));
            }
        },

        on_finish: function (data) {
            console.log('Experiment completed. Saving complete dataset...');
            
            dataHandler.submitCompleteData({
            format: 'csv',
            metadata: {
                completion_status: 'successful',
                total_time: jsPsych.getTotalTime()
            }
            })
            .then(result => {
            console.log('Data save result:', result);
            
            const method = result.method === 'server' ? 'uploaded to the server' : 'downloaded to your computer';
            document.querySelector('.jspsych-content').innerHTML = 
                `<div style="text-align: center; padding: 40px;">
                <h2>Thank you for participating!</h2>
                <p>Your data has been successfully ${method}.</p>
                <p style="color: #666; font-size: 0.9em;">
                    ${result.method === 'local' ? `File: <strong>${result.filename}</strong><br>Check your Downloads folder.` : 'You may now close this window.'}
                </p>
                </div>`;
            })
            .catch(error => {
            console.error('Failed to save complete data:', error);
            
            document.querySelector('.jspsych-content').innerHTML = 
                `<div style="text-align: center; padding: 40px;">
                <h2>Data Save Error</h2>
                <p style="color: #cc0000;">Error: ${error.message}</p>
                <button onclick="downloadBackupData()" style="padding: 10px 20px; font-size: 16px;">
                    Download Backup Data
                </button>
                </div>`;
            });
            
            document.documentElement.classList.remove('hide-cursor')
        },
    });

    // Create data handler
    const dataHandler = new JsPsychDataHandler(jsPsych, {
        serverUrl: 'https://pathplanning-server.onrender.com',
        experimentName: 'path_planning_study',
        fallbackToLocal: true
    });

    console.log('Environment info:', dataHandler.getEnvironmentInfo());

    // Emergency backup download
    window.downloadBackupData = function() {
      try {
        const allData = jsPsych.data.get().values();
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `emergency_backup_${timestamp}.json`;
        
        const content = JSON.stringify({
          participant_id: dataHandler.participantId,
          timestamp: new Date().toISOString(),
          data: allData,
          note: 'Emergency backup'
        }, null, 2);
        
        dataHandler.downloadFile(content, filename, 'application/json');
        alert('Backup downloaded: ' + filename);
      } catch (error) {
        alert('Backup failed: ' + error.message);
      }
    };

    // --- Preload Images ---
    const preload_images = [...new Set(Object.values(TRIAL_CONDITIONS))].map(img => base_image_path + img);

    const preload_trial = {
    type: jsPsychPreload,
    images: preload_images,
    message: 'Loading experiment. Please wait...',
    };

    // --- Full screen ---
    const enter_fullscreen = {
      type: jsPsychFullscreen,
      message: '<p style="max-width:700px;margin:0 auto;">This experiment works best in fullscreen.</p>',
      fullscreen_mode: true
    };

    const exit_fullscreen = {
        type: jsPsychFullscreen,
        fullscreen_mode: false
    }

    // --- Hide/show cursor ---
    const hide_cursor = {
        type: jsPsychCallFunction,
        func: () => document.documentElement.classList.add('hide-cursor')
    };

    const show_cursor = {
        type: jsPsychCallFunction,
        func: () => document.documentElement.classList.remove('hide-cursor')
    };

    // --- Instructions Page ---
    const instructions = {
      type: jsPsychInstructions,
      pages: [
        `<p style="font-size:1.2rem;"><strong>Find the right piece!</strong></p>
         <p>You'll briefly see blocky maze shapes. Press the <strong>spacebar</strong> only when you see this exact image:</p>
         <img src="${base_image_path + target_image}" style="max-width:250px;display:block;margin:16px auto 8px;" alt="Target">
         <p>The images will flash for a short time, so act quickly.</p>`,
        `<p>If the computer recognizes your key press, the frame around the display will briefly flash.</p>
         <p>On the next screen, try pressing the <strong>spacebar</strong> to test the flash; then you'll start the main task.</p>`
      ],
      show_clickable_nav: true,
      button_label_next: 'Next',
      button_label_previous: 'Back'
    };

    function mountFrameAndFeedback() {
        const root = jsPsych.getDisplayElement();

        // 1) Ensure a persistent wrapper exists for this trial
        let frame = root.querySelector('#stimulus-frame');
        if (!frame) {
            frame = document.createElement('div');
            frame.id = 'stimulus-frame';
            frame.className = 'stimulus-frame';
            root.appendChild(frame);
        }

        let content = frame.querySelector('.frame-content');
        if (!content) {
            content = document.createElement('div');
            content.className = 'frame-content';
            frame.appendChild(content);
        }

        // read --stimulus-size and lock it inline
        const cssSize = getComputedStyle(frame).getPropertyValue('--stimulus-size').trim() || '350px';
        content.style.width = cssSize;
        content.style.height = cssSize;
        content.style.flex = '0 0 auto';

        let overlay = content.querySelector('.stimulus-overlay');
        if (!overlay) {
            overlay = document.createElement('div');
            overlay.className = 'stimulus-overlay';
            content.appendChild(overlay);
        }

        let fixation = overlay.querySelector('.fixation');
        if (!fixation) {
            fixation = document.createElement('div');
            fixation.className = 'fixation';
            fixation.setAttribute('aria-hidden', 'true');
            overlay.appendChild(fixation);
        }

        // 2) Move the stimulus into the frame whenever it (re)appears
        let isTarget = null; // cached as soon as we see the stimulus

        const identifyAndMount = () => {
            const stim = root.querySelector('#jspsych-image-keyboard-response-stimulus');
            if (!stim) return;

            // Move stimulus into the overlay
            if (stim.parentElement !== overlay) {
                overlay.appendChild(stim);

                // remove HTML attrs that can override CSS sizing
                stim.removeAttribute('width');
                stim.removeAttribute('height');
                // enforce our sizing
                stim.style.width = '100%';
                stim.style.height = '100%';
                stim.style.objectFit = 'contain';

                // attach once per <img> element
                stim.addEventListener('load', () => { stim.classList.remove('broken'); stim.style.opacity = '1'; }, {once: true});
                stim.addEventListener('error', () => { stim.classList.add('broken');}, {once: true});

                // if src is currently empty (typical during ISI), hide now
                const hasSrc = !!stim.getAttribute('src');
                stim.style.opacity = hasSrc ? '1' : '0';
            }

            // Determine target/non-target from the <img src>
            // Works because you set render_on_canvas:false (so it’s an <img>)
            if (isTarget === null && stim.tagName === 'IMG') {
                try {
                    const src = stim.getAttribute('src') || '';
                    isTarget =
                        src.endsWith('/' + target_image) ||
                        src.endsWith('\\' + target_image) ||
                        src.endsWith(target_image);
                } catch {
                    isTarget = false;
                }
            }
        };

        identifyAndMount();
        const obs = new MutationObserver(identifyAndMount);
        obs.observe(root, { childList: true, subtree: true });

        // 3) Color the existing border on Space
        let responded = false;
        function onKey(e) {
            if (e.key !== ' ' || responded) return;
            responded = true;

            // If we somehow haven't seen the stimulus yet, assume non-target (conservative)
            const correct = !!isTarget;
            frame.classList.toggle('frame-correct', correct);
            frame.classList.toggle('frame-wrong', !correct);

            setTimeout(() => {
            frame.classList.remove('frame-correct', 'frame-wrong');
            responded = false; // allow recolor on additional presses if needed
            }, feedbackDuration);
        }
        document.addEventListener('keydown', onKey);

        // 4) Cleanup at trial end
        return () => {
            document.removeEventListener('keydown', onKey);
            obs.disconnect();
            if (frame) frame.classList.remove('frame-correct', 'frame-wrong');
        };
    }

    function lockPointerForTask() {
        const el = jsPsych.getDisplayElement();

        function requestLock() {
            if (document.pointerLockElement !== el) el.requestPointerLock();
        }

        function onChange() {
            // If lock is lost mid-trial (e.g., Esc), try to re-lock on next click
            if (document.pointerLockElement !== el) {
            el.addEventListener('click', requestLock, { once: true });
            }
        }

        document.addEventListener('pointerlockchange', onChange);
        el.addEventListener('click', requestLock, { once: true }); // first click to lock

        // Return cleanup
        return () => {
            document.removeEventListener('pointerlockchange', onChange);
            if (document.pointerLockElement === el) document.exitPointerLock();
        };
    }

    const practice_screen = {
        type: jsPsychHtmlButtonResponse,
        stimulus: `
        <div style="display:flex;flex-direction:column;align-items:center;">
            <div id="stimulus-frame" class="stimulus-frame">
                <div class="frame-content">
                    <div class="stimulus-overlay">
                        <img id="jspsych-image-keyboard-response-stimulus" alt="" />
                    <div class="fixation" aria-hidden="true"></div>
                </div>
            </div>
            <p id="practice-instruction" class="frame-caption"></p>
        </div>
        `,
        choices: ['Start the experiment'],   // let plugin use its default button HTML (no button_html param)
        on_load: function () {
            const frame = document.getElementById('stimulus-frame');
            const img   = document.getElementById('jspsych-image-keyboard-response-stimulus');
            const instr = document.getElementById('practice-instruction');

            let isTarget = false;
            let stopped = false;
            const timers = [];

            // pick a random condition each cycle
            function pickStimulus() {
            const tv = jsPsych.randomization.sampleWithoutReplacement(timeline_variables, 1)[0];
            isTarget = (tv.trial_condition === 'target');
            instr.textContent = isTarget ? 'Press the spacebar!' : 'Do NOT press the spacebar!';
            return tv.image_path;
            }

            function cycle() {
            if (stopped) return;

            // show stimulus
            img.src = pickStimulus();
            instr.style.visibility = 'visible';

            // hide stimulus after the usual flash duration (frame stays visible)
            timers.push(setTimeout(() => {
                img.removeAttribute('src'); // blank during ITI
                instr.style.visibility = 'hidden'; // also hide instruction
            }, shapePresentationDuration));

            // schedule next cycle (stimulus + ITI)
            timers.push(setTimeout(cycle, shapePresentationDuration + iti));
            }

            function onKey(e) {
            if (e.key !== ' ') return;
            e.preventDefault();

            // same feedback rule as the task: green on target, red on non-target
            frame.classList.remove('frame-correct', 'frame-wrong');
            frame.classList.add(isTarget ? 'frame-correct' : 'frame-wrong');

            setTimeout(() => {
                frame.classList.remove('frame-correct', 'frame-wrong');
            }, feedbackDuration);
            }

            document.addEventListener('keydown', onKey);
            cycle();

            // cleanup when the button is clicked
            window._practice_cleanup = () => {
            stopped = true;
            timers.forEach(clearTimeout);
            document.removeEventListener('keydown', onKey);
            frame.classList.remove('frame-correct', 'frame-wrong');
            img.removeAttribute('src');
            };
        },
        on_finish: function () {
            if (window._practice_cleanup) window._practice_cleanup();
        }
    };


    // --- Experiment Trials ---

    const timeline_variables = Object.keys(TRIAL_CONDITIONS).map(t => ({
        trial_condition: t,
        image_path: base_image_path + TRIAL_CONDITIONS[t]
    }));

    let trial_count = 0;
    const total_trials = nTrialsPerImage * timeline_variables.length;

    const main_trial = {
        type: jsPsychImageKeyboardResponse,
        stimulus: jsPsych.timelineVariable('image_path'),
        render_on_canvas: false,
        choices: [' '],
        response_ends_trial: false,
        stimulus_duration: shapePresentationDuration,
        trial_duration: shapePresentationDuration + iti,
        data: {
            trial_condition: jsPsych.timelineVariable('trial_condition'),
            is_target: () => jsPsych.timelineVariable('trial_condition') === 'target'
        },
        on_timeline_start: () => { jsPsych.progressBar.progress = 0; },
        on_load: () => { 
            window._cleanup = mountFrameAndFeedback();
        },
        on_finish: function(data) {
            if (window._cleanup) window._cleanup();

            const didRespond = data.response !== null;
            const isTarget = data.is_target === true || data.is_target === 'true'; // robust

            data.correct = isTarget ? didRespond : !didRespond;
            data.response_given = didRespond;

            trial_count += 1;
            jsPsych.progressBar.progress = trial_count / total_trials;
        }
    }

    const main_procedure = {
        timeline: [main_trial],
        timeline_variables: timeline_variables,
        repetitions: nTrialsPerImage,
        randomize_order: true
    }

    var final_survey = {
        type: jsPsychSurveyText,
        questions: [
            {prompt: 'Do you have any comments?', rows: 8}
        ]
    }

    // --- Construct the Experiment Timeline ---
    const timeline = [];
    timeline.push(preload_trial);
    timeline.push(enter_fullscreen);
    timeline.push(instructions);
    timeline.push(practice_screen);
    timeline.push(hide_cursor);
    timeline.push({
        type: jsPsychCallFunction,
        func: () => { window._unlock = lockPointerForTask(); }
    });
    timeline.push(main_procedure);
    timeline.push({
        type: jsPsychCallFunction,
        func: () => { if (window._unlock) window._unlock(); }
    });
    timeline.push(show_cursor);
    timeline.push(final_survey);
    timeline.push(exit_fullscreen);

    jsPsych.run(timeline);

</script>
</body>
</html>
