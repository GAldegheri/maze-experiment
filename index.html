<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Maze Navigation Experiment</title>

  <!-- jsPsych core + CSS -->
  <link href="https://unpkg.com/jspsych@8.2.1/css/jspsych.css" rel="stylesheet" type="text/css" />
  <script src="https://unpkg.com/jspsych@8.2.1"></script>

  <!-- Plugins -->
  <script src="https://unpkg.com/@jspsych/plugin-preload@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-instructions@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-image-keyboard-response@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-fullscreen@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-call-function@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-text@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-button-response@2.1.0"></script>

  <!-- Optional data handler the original file used -->
  <script src="modular-data-handler.js"></script>

  <style>
    
    :root {
      --stimulus-size: 350px;
      --frame-gap: 50px;
      --frame-border: 20px;
      --frame-color: #000000;
      --feedback-correct: #008000;
      --feedback-wrong: #FF0000; /* reserved if you later add wrong feedback */
      --content-max: 1024px;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #fff;
      color: #000;
      font-family: Helvetica, Arial, sans-serif;
      font-size: 16px;
    }

    /* Keep jsPsych centered and sized */
    .jspsych-content {
      max-width: var(--content-max);
      margin: 0 auto;
      padding: 5vh 2vw;
      box-sizing: border-box;
      text-align: center;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 60vh;
    }

    .stimulus-frame {
        width:  calc(var(--stimulus-size) + 2 * var(--frame-gap));
        height: calc(var(--stimulus-size) + 2 * var(--frame-gap));
        padding: var(--frame-gap);
        border: var(--frame-border) solid var(--frame-color);
        margin: 2vh auto;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #fff;
        box-sizing: content-box;
    }

   .stimulus-frame.frame-correct { border-color: var(--feedback-correct) !important; }
   .stimulus-frame.frame-wrong   { border-color: var(--feedback-wrong) !important; }

    /* size the stimulus image (if rendered as <img>) */
    #jspsych-image-keyboard-response-stimulus {
        width:  var(--stimulus-size);
        height: auto;
        max-width: 100%;
        max-height: 100%;
        display: block;
    }


    /* Fixed progress bar at top (using jsPsych's built-in container) */
    .jspsych-progress-bar-container {
      display: block;
      margin-top: 0;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      z-index: 1000;
      padding: 6px 0;
      border-bottom: 1px solid #ddd;
      background-color: #fff;
    }

    .hide-cursor, .hide-cursor * {
        cursor: none !important;
    }

  </style>
</head>

<body>
<div id="jspsych-target"></div>

<script>

    // --- Experiment Parameters ---
    const base_image_path = "maze_images/";

    const TRIAL_CONDITIONS = {
        "far": "maze_initial_small.png",
        "closer": "maze_closer_small.png",
        "closest": "maze_closest_small.png",
        "target": "maze_goal_small.png"
    }

    const target_image = TRIAL_CONDITIONS["target"]; // The target image participants should respond to
    const nTrialsPerImage = 30; // How many times each image appears
    const targetRepeats = 10; // How many times target appears per cycle

    const iti = 1200; // Inter-trial interval (msec)
    const shapePresentationDuration = 600; // Image display duration (msec)

    const feedbackColor = '#008000'; // Green for correct responses
    const wrongColor = '#FF0000'; // Red for incorrect responses
    const feedbackDuration = 300; // How long the border color stays changed after a response

    const jsPsych = initJsPsych({
        override_safe_mode: true,
        show_progress_bar: true,
        message_progress_bar: 'Progress',
        auto_update_progress_bar: false,

        // Set callbacks
        on_data_update: function(data){
            console.log('on_data_update called!', data.trial_type);

            if (dataHandler.isLocal){
                // Local mode - download data
                console.log('Trial data collected (local):', {
                trial_type: data.trial_type,
                trial_index: data.trial_index,
                rt: data.rt,
                response: data.response
            });
            } else {
                // Server mode
                dataHandler.submitData(data)
                    .then(result => console.log('Trial data submitted:', result.method))
                    .catch(error => console.error('Trial submission failed:', error));
            }
        },

        on_finish: function (data) {
            console.log('Experiment completed. Saving complete dataset...');
            
            dataHandler.submitCompleteData({
            format: 'csv',
            metadata: {
                completion_status: 'successful',
                total_time: jsPsych.getTotalTime()
            }
            })
            .then(result => {
            console.log('Data save result:', result);
            
            const method = result.method === 'server' ? 'uploaded to the server' : 'downloaded to your computer';
            document.querySelector('.jspsych-content').innerHTML = 
                `<div style="text-align: center; padding: 40px;">
                <h2>Thank you for participating!</h2>
                <p>Your data has been successfully ${method}.</p>
                <p style="color: #666; font-size: 0.9em;">
                    ${result.method === 'local' ? `File: <strong>${result.filename}</strong><br>Check your Downloads folder.` : 'You may now close this window.'}
                </p>
                </div>`;
            })
            .catch(error => {
            console.error('Failed to save complete data:', error);
            
            document.querySelector('.jspsych-content').innerHTML = 
                `<div style="text-align: center; padding: 40px;">
                <h2>Data Save Error</h2>
                <p style="color: #cc0000;">Error: ${error.message}</p>
                <button onclick="downloadBackupData()" style="padding: 10px 20px; font-size: 16px;">
                    Download Backup Data
                </button>
                </div>`;
            });
            
            document.documentElement.classList.remove('hide-cursor')
        },
    });

    // Create data handler
    const dataHandler = new JsPsychDataHandler(jsPsych, {
        serverUrl: 'https://pathplanning-server.onrender.com',
        experimentName: 'path_planning_study',
        fallbackToLocal: true
    });

    console.log('Environment info:', dataHandler.getEnvironmentInfo());

    // Emergency backup download
    window.downloadBackupData = function() {
      try {
        const allData = jsPsych.data.get().values();
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `emergency_backup_${timestamp}.json`;
        
        const content = JSON.stringify({
          participant_id: dataHandler.participantId,
          timestamp: new Date().toISOString(),
          data: allData,
          note: 'Emergency backup'
        }, null, 2);
        
        dataHandler.downloadFile(content, filename, 'application/json');
        alert('Backup downloaded: ' + filename);
      } catch (error) {
        alert('Backup failed: ' + error.message);
      }
    };

    // --- Preload Images ---
    const preload_images = [...new Set(Object.values(TRIAL_CONDITIONS))].map(img => base_image_path + img);

    const preload_trial = {
    type: jsPsychPreload,
    images: preload_images,
    message: 'Loading experiment. Please wait...',
    };

    // --- Full screen ---
    const enter_fullscreen = {
      type: jsPsychFullscreen,
      message: '<p style="max-width:700px;margin:0 auto;">This experiment works best in fullscreen.</p>',
      fullscreen_mode: true
    };

    const exit_fullscreen = {
        type: jsPsychFullscreen,
        fullscreen_mode: false
    }

    // --- Hide/show cursor ---
    const hide_cursor = {
        type: jsPsychCallFunction,
        func: () => document.documentElement.classList.add('hide-cursor')
    };

    const show_cursor = {
        type: jsPsychCallFunction,
        func: () => document.documentElement.classList.remove('hide-cursor')
    };

    // --- Instructions Page ---
    const instructions = {
      type: jsPsychInstructions,
      pages: [
        `<p style="font-size:1.2rem;"><strong>Find the right piece!</strong></p>
         <p>You'll briefly see blocky maze shapes. Press the <strong>spacebar</strong> only when you see this exact image:</p>
         <img src="${base_image_path + target_image}" style="max-width:250px;display:block;margin:16px auto 8px;" alt="Target">
         <p>The images will flash for a short time, so act quickly.</p>`,
        `<p>If the computer recognizes your key press, the frame around the display will briefly flash.</p>
         <p>On the next screen, try pressing the <strong>spacebar</strong> to test the flash; then you'll start the main task.</p>`
      ],
      show_clickable_nav: true,
      button_label_next: 'Next',
      button_label_previous: 'Back'
    };

    function mountFrameAndFeedback() {
        const root = jsPsych.getDisplayElement();

        // 1) Ensure a persistent wrapper exists for this trial
        let frame = root.querySelector('#stimulus-frame');
        if (!frame) {
            frame = document.createElement('div');
            frame.id = 'stimulus-frame';
            frame.className = 'stimulus-frame';
            root.appendChild(frame);
        } else {
            frame.className = 'stimulus-frame'; // reset border color classes
        }

        // 2) Move the stimulus into the frame whenever it (re)appears
        let isTarget = null; // cached as soon as we see the stimulus

        const identifyAndMount = () => {
            const stim = root.querySelector('#jspsych-image-keyboard-response-stimulus');
            if (!stim) return;

            // Move stimulus into the persistent frame
            if (stim.parentElement !== frame) frame.appendChild(stim);

            // Determine target/non-target from the <img src>
            // Works because you set render_on_canvas:false (so itâ€™s an <img>)
            if (isTarget === null && stim.tagName === 'IMG') {
            try {
                const src = stim.getAttribute('src') || '';
                // Use endsWith to avoid absolute/relative path differences
                isTarget = src.endsWith('/' + target_image) || src.endsWith('\\' + target_image) || src.endsWith(target_image);
            } catch (_) {
                isTarget = false;
            }
            }
        };

        identifyAndMount();
        const obs = new MutationObserver(identifyAndMount);
        obs.observe(root, { childList: true, subtree: true });

        // 3) Color the existing border on Space
        let responded = false;
        function onKey(e) {
            if (e.key !== ' ' || responded) return;
            responded = true;

            // If we somehow haven't seen the stimulus yet, assume non-target (conservative)
            const correct = !!isTarget;

            frame.classList.remove('frame-correct', 'frame-wrong');
            frame.classList.add(correct ? 'frame-correct' : 'frame-wrong');

            setTimeout(() => {
            frame.classList.remove('frame-correct', 'frame-wrong');
            responded = false; // allow recolor on additional presses if needed
            }, feedbackDuration);
        }
        document.addEventListener('keydown', onKey);

        // 4) Cleanup at trial end
        return () => {
            document.removeEventListener('keydown', onKey);
            obs.disconnect();
            if (frame) frame.classList.remove('frame-correct', 'frame-wrong');
        };
    }

    function lockPointerForTask() {
        const el = jsPsych.getDisplayElement();

        function requestLock() {
            if (document.pointerLockElement !== el) el.requestPointerLock();
        }

        function onChange() {
            // If lock is lost mid-trial (e.g., Esc), try to re-lock on next click
            if (document.pointerLockElement !== el) {
            el.addEventListener('click', requestLock, { once: true });
            }
        }

        document.addEventListener('pointerlockchange', onChange);
        el.addEventListener('click', requestLock, { once: true }); // first click to lock

        // Return cleanup
        return () => {
            document.removeEventListener('pointerlockchange', onChange);
            if (document.pointerLockElement === el) document.exitPointerLock();
        };
    }

    const practice_screen = {
        type: jsPsychHtmlButtonResponse,
        stimulus: `
            <div style="display:flex;flex-direction:column;align-items:center;">
            <div id="stimulus-frame" class="stimulus-frame">
                <!-- IMPORTANT: same ID as the main task uses -->
                <img id="jspsych-image-keyboard-response-stimulus" alt="" />
            </div>
            <p id="practice-instruction" style="margin-top:12px;font-weight:600;"></p>
            </div>
        `,
        choices: ['Start the experiment'],   // let plugin use its default button HTML (no button_html param)
        on_load: function () {
            const frame = document.getElementById('stimulus-frame');
            const img   = document.getElementById('jspsych-image-keyboard-response-stimulus');
            const instr = document.getElementById('practice-instruction');

            let isTarget = false;
            let stopped = false;
            const timers = [];

            // pick a random condition each cycle
            function pickStimulus() {
            const tv = jsPsych.randomization.sampleWithoutReplacement(timeline_variables, 1)[0];
            isTarget = (tv.trial_condition === 'target');
            instr.textContent = isTarget ? 'Press the spacebar' : 'Do NOT press the spacebar';
            return tv.image_path;
            }

            function cycle() {
            if (stopped) return;

            // show stimulus
            img.src = pickStimulus();

            // hide stimulus after the usual flash duration (frame stays visible)
            timers.push(setTimeout(() => {
                img.removeAttribute('src'); // blank during ITI
            }, shapePresentationDuration));

            // schedule next cycle (stimulus + ITI)
            timers.push(setTimeout(cycle, shapePresentationDuration + iti));
            }

            function onKey(e) {
            if (e.key !== ' ') return;
            e.preventDefault();

            // same feedback rule as the task: green on target, red on non-target
            frame.classList.remove('frame-correct', 'frame-wrong');
            frame.classList.add(isTarget ? 'frame-correct' : 'frame-wrong');

            setTimeout(() => {
                frame.classList.remove('frame-correct', 'frame-wrong');
            }, feedbackDuration);
            }

            document.addEventListener('keydown', onKey);
            cycle();

            // cleanup when the button is clicked
            window._practice_cleanup = () => {
            stopped = true;
            timers.forEach(clearTimeout);
            document.removeEventListener('keydown', onKey);
            frame.classList.remove('frame-correct', 'frame-wrong');
            img.removeAttribute('src');
            };
        },
        on_finish: function () {
            if (window._practice_cleanup) window._practice_cleanup();
        }
    };


    // --- Experiment Trials ---

    const timeline_variables = Object.keys(TRIAL_CONDITIONS).map(t => ({
        trial_condition: t,
        image_path: base_image_path + TRIAL_CONDITIONS[t]
    }));

    let trial_count = 0;
    const total_trials = nTrialsPerImage * timeline_variables.length;

    const main_trial = {
        type: jsPsychImageKeyboardResponse,
        stimulus: jsPsych.timelineVariable('image_path'),
        render_on_canvas: false,
        choices: [' '],
        response_ends_trial: false,
        stimulus_duration: shapePresentationDuration,
        trial_duration: shapePresentationDuration + iti,
        data: {
            trial_condition: jsPsych.timelineVariable('trial_condition'),
            is_target: () => jsPsych.timelineVariable('trial_condition') === 'target'
        },
        on_timeline_start: () => { jsPsych.progressBar.progress = 0; },
        on_load: () => { 
            window._cleanup = mountFrameAndFeedback();
        },
        on_finish: function(data) {
            if (window._cleanup) window._cleanup();

            const didRespond = data.response !== null;
            const isTarget = data.is_target === true || data.is_target === 'true'; // robust

            data.correct = isTarget ? didRespond : !didRespond;
            data.response_given = didRespond;

            trial_count += 1;
            jsPsych.progressBar.progress = trial_count / total_trials;
        }
    }

    const main_procedure = {
        timeline: [main_trial],
        timeline_variables: timeline_variables,
        repetitions: nTrialsPerImage,
        randomize_order: true
    }

    var final_survey = {
        type: jsPsychSurveyText,
        questions: [
            {prompt: 'Do you have any comments?', rows: 8}
        ]
    }

    // --- Construct the Experiment Timeline ---
    const timeline = [];
    timeline.push(preload_trial);
    timeline.push(enter_fullscreen);
    timeline.push(instructions);
    timeline.push(practice_screen);
    timeline.push(hide_cursor);
    timeline.push({
        type: jsPsychCallFunction,
        func: () => { window._unlock = lockPointerForTask(); }
    });
    timeline.push(main_procedure);
    timeline.push({
        type: jsPsychCallFunction,
        func: () => { if (window._unlock) window._unlock(); }
    });
    timeline.push(show_cursor);
    timeline.push(final_survey);
    timeline.push(exit_fullscreen);

    jsPsych.run(timeline);

</script>
</body>
</html>
